// Code generated by Prisma Client Go. DO NOT EDIT.
//nolint
//go:build !codeanalysis
// +build !codeanalysis

package teste

import (
	"context"
	"os"
	"testing"

	"github.com/prisma/prisma-client-go/engine"
	"github.com/prisma/prisma-client-go/engine/mock"
	"github.com/prisma/prisma-client-go/runtime/builder"
	"github.com/prisma/prisma-client-go/runtime/lifecycle"
	"github.com/prisma/prisma-client-go/runtime/raw"
	"github.com/prisma/prisma-client-go/runtime/transaction"
	"github.com/prisma/prisma-client-go/runtime/types"

	// no-op import for go modules
	_ "github.com/iancoleman/strcase"
	_ "github.com/joho/godotenv"
	_ "github.com/shopspring/decimal"
	_ "github.com/takuoki/gocase"
)

// ignore unused os import as it may not be needed depending on engine type
var _ = os.DevNull

// re-declare variables which are needed in Prisma Client Go but also should be exported
// in the generated client

const RFC3339Milli = types.RFC3339Milli

type BatchResult = types.BatchResult

type DateTime = types.DateTime
type JSON = types.JSON
type Bytes = types.Bytes
type BigInt = types.BigInt
type Decimal = types.Decimal

// deprecated: use SortOrder
type Direction = SortOrder

const (
	// deprecated: use SortOrderAsc
	ASC Direction = "asc"
	// deprecated: use SortOrderDesc
	DESC Direction = "desc"
)

// --- template actions.gotpl ---
var countOutput = []builder.Output{
	{Name: "count"},
}

type userActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var userOutput = []builder.Output{
	{Name: "id"},
	{Name: "created_at"},
	{Name: "updated_at"},
	{Name: "first_name"},
	{Name: "last_name"},
	{Name: "email"},
	{Name: "age"},
}

type UserRelationWith interface {
	getQuery() builder.Query
	with()
	userRelation()
}

type UserWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
}

type userDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p userDefaultParam) field() builder.Field {
	return p.data
}

func (p userDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p userDefaultParam) userModel() {}

type UserOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
}

type userOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p userOrderByParam) field() builder.Field {
	return p.data
}

func (p userOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p userOrderByParam) userModel() {}

type UserCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	isCursor()
}

type userCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p userCursorParam) field() builder.Field {
	return p.data
}

func (p userCursorParam) isCursor() {}

func (p userCursorParam) getQuery() builder.Query {
	return p.query
}

func (p userCursorParam) userModel() {}

type UserParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	userModel()
}

type userParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p userParamUnique) userModel() {}

func (userParamUnique) unique() {}

func (p userParamUnique) field() builder.Field {
	return p.data
}

func (p userParamUnique) getQuery() builder.Query {
	return p.query
}

type UserEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
}

type userEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userEqualsParam) userModel() {}

func (userEqualsParam) equals() {}

func (p userEqualsParam) field() builder.Field {
	return p.data
}

func (p userEqualsParam) getQuery() builder.Query {
	return p.query
}

type UserEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	userModel()
}

type userEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userEqualsUniqueParam) userModel() {}

func (userEqualsUniqueParam) unique() {}
func (userEqualsUniqueParam) equals() {}

func (p userEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type UserSetParam interface {
	field() builder.Field
	settable()
	userModel()
}

type userSetParam struct {
	data builder.Field
}

func (userSetParam) settable() {}

func (p userSetParam) field() builder.Field {
	return p.data
}

func (p userSetParam) userModel() {}

type UserWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	idField()
}

type UserWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	idField()
}

type userWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaIDSetParam) userModel() {}

func (p userWithPrismaIDSetParam) idField() {}

type UserWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	idField()
}

type userWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaIDEqualsParam) userModel() {}

func (p userWithPrismaIDEqualsParam) idField() {}

func (userWithPrismaIDSetParam) settable()  {}
func (userWithPrismaIDEqualsParam) equals() {}

type userWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaIDEqualsUniqueParam) userModel() {}
func (p userWithPrismaIDEqualsUniqueParam) idField()   {}

func (userWithPrismaIDEqualsUniqueParam) unique() {}
func (userWithPrismaIDEqualsUniqueParam) equals() {}

type UserWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	createdAtField()
}

type UserWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	createdAtField()
}

type userWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaCreatedAtSetParam) userModel() {}

func (p userWithPrismaCreatedAtSetParam) createdAtField() {}

type UserWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	createdAtField()
}

type userWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaCreatedAtEqualsParam) userModel() {}

func (p userWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (userWithPrismaCreatedAtSetParam) settable()  {}
func (userWithPrismaCreatedAtEqualsParam) equals() {}

type userWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaCreatedAtEqualsUniqueParam) userModel()      {}
func (p userWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (userWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (userWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type UserWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	updatedAtField()
}

type UserWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	updatedAtField()
}

type userWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUpdatedAtSetParam) userModel() {}

func (p userWithPrismaUpdatedAtSetParam) updatedAtField() {}

type UserWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	updatedAtField()
}

type userWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUpdatedAtEqualsParam) userModel() {}

func (p userWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (userWithPrismaUpdatedAtSetParam) settable()  {}
func (userWithPrismaUpdatedAtEqualsParam) equals() {}

type userWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUpdatedAtEqualsUniqueParam) userModel()      {}
func (p userWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField() {}

func (userWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (userWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type UserWithPrismaFirstNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	firstNameField()
}

type UserWithPrismaFirstNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	firstNameField()
}

type userWithPrismaFirstNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaFirstNameSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaFirstNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaFirstNameSetParam) userModel() {}

func (p userWithPrismaFirstNameSetParam) firstNameField() {}

type UserWithPrismaFirstNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	firstNameField()
}

type userWithPrismaFirstNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaFirstNameEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaFirstNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaFirstNameEqualsParam) userModel() {}

func (p userWithPrismaFirstNameEqualsParam) firstNameField() {}

func (userWithPrismaFirstNameSetParam) settable()  {}
func (userWithPrismaFirstNameEqualsParam) equals() {}

type userWithPrismaFirstNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaFirstNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaFirstNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaFirstNameEqualsUniqueParam) userModel()      {}
func (p userWithPrismaFirstNameEqualsUniqueParam) firstNameField() {}

func (userWithPrismaFirstNameEqualsUniqueParam) unique() {}
func (userWithPrismaFirstNameEqualsUniqueParam) equals() {}

type UserWithPrismaLastNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	lastNameField()
}

type UserWithPrismaLastNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	lastNameField()
}

type userWithPrismaLastNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaLastNameSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaLastNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaLastNameSetParam) userModel() {}

func (p userWithPrismaLastNameSetParam) lastNameField() {}

type UserWithPrismaLastNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	lastNameField()
}

type userWithPrismaLastNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaLastNameEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaLastNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaLastNameEqualsParam) userModel() {}

func (p userWithPrismaLastNameEqualsParam) lastNameField() {}

func (userWithPrismaLastNameSetParam) settable()  {}
func (userWithPrismaLastNameEqualsParam) equals() {}

type userWithPrismaLastNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaLastNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaLastNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaLastNameEqualsUniqueParam) userModel()     {}
func (p userWithPrismaLastNameEqualsUniqueParam) lastNameField() {}

func (userWithPrismaLastNameEqualsUniqueParam) unique() {}
func (userWithPrismaLastNameEqualsUniqueParam) equals() {}

type UserWithPrismaEmailEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	emailField()
}

type UserWithPrismaEmailSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	emailField()
}

type userWithPrismaEmailSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaEmailSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaEmailSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaEmailSetParam) userModel() {}

func (p userWithPrismaEmailSetParam) emailField() {}

type UserWithPrismaEmailWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	emailField()
}

type userWithPrismaEmailEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaEmailEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaEmailEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaEmailEqualsParam) userModel() {}

func (p userWithPrismaEmailEqualsParam) emailField() {}

func (userWithPrismaEmailSetParam) settable()  {}
func (userWithPrismaEmailEqualsParam) equals() {}

type userWithPrismaEmailEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaEmailEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaEmailEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaEmailEqualsUniqueParam) userModel()  {}
func (p userWithPrismaEmailEqualsUniqueParam) emailField() {}

func (userWithPrismaEmailEqualsUniqueParam) unique() {}
func (userWithPrismaEmailEqualsUniqueParam) equals() {}

type UserWithPrismaAgeEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	ageField()
}

type UserWithPrismaAgeSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	ageField()
}

type userWithPrismaAgeSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaAgeSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaAgeSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaAgeSetParam) userModel() {}

func (p userWithPrismaAgeSetParam) ageField() {}

type UserWithPrismaAgeWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	ageField()
}

type userWithPrismaAgeEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaAgeEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaAgeEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaAgeEqualsParam) userModel() {}

func (p userWithPrismaAgeEqualsParam) ageField() {}

func (userWithPrismaAgeSetParam) settable()  {}
func (userWithPrismaAgeEqualsParam) equals() {}

type userWithPrismaAgeEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaAgeEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaAgeEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaAgeEqualsUniqueParam) userModel() {}
func (p userWithPrismaAgeEqualsUniqueParam) ageField()  {}

func (userWithPrismaAgeEqualsUniqueParam) unique() {}
func (userWithPrismaAgeEqualsUniqueParam) equals() {}

// --- template create.gotpl ---

// Creates a single user.
func (r userActions) CreateOne(
	_firstName UserWithPrismaFirstNameSetParam,
	_lastName UserWithPrismaLastNameSetParam,
	_email UserWithPrismaEmailSetParam,

	optional ...UserSetParam,
) userCreateOne {
	var v userCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "User"
	v.query.Outputs = userOutput

	var fields []builder.Field

	fields = append(fields, _firstName.field())
	fields = append(fields, _lastName.field())
	fields = append(fields, _email.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r userCreateOne) With(params ...UserRelationWith) userCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type userCreateOne struct {
	query builder.Query
}

func (p userCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p userCreateOne) userModel() {}

func (r userCreateOne) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userCreateOne) Tx() userUniqueTxResult {
	v := NewuserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template find.gotpl ---

type userFindUnique struct {
	query builder.Query
}

func (r userFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userFindUnique) with()         {}
func (r userFindUnique) userModel()    {}
func (r userFindUnique) userRelation() {}

func (r userActions) FindUnique(
	params UserEqualsUniqueWhereParam,
) userFindUnique {
	var v userFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "User"
	v.query.Outputs = userOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r userFindUnique) With(params ...UserRelationWith) userFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userFindUnique) Update(params ...UserSetParam) userUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userUpdateUnique struct {
	query builder.Query
}

func (r userUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userUpdateUnique) userModel() {}

func (r userUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userUpdateUnique) Tx() userUniqueTxResult {
	v := NewuserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userFindUnique) Delete() userDeleteUnique {
	var v userDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userDeleteUnique struct {
	query builder.Query
}

func (r userDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userDeleteUnique) userModel() {}

func (r userDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userDeleteUnique) Tx() userUniqueTxResult {
	v := NewuserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userFindFirst struct {
	query builder.Query
}

func (r userFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userFindFirst) with()         {}
func (r userFindFirst) userModel()    {}
func (r userFindFirst) userRelation() {}

func (r userActions) FindFirst(
	params ...UserWhereParam,
) userFindFirst {
	var v userFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "User"
	v.query.Outputs = userOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userFindFirst) With(params ...UserRelationWith) userFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userFindFirst) OrderBy(params ...UserOrderByParam) userFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userFindFirst) Skip(count int) userFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userFindFirst) Take(count int) userFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userFindFirst) Cursor(cursor UserCursorParam) userFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userFindMany struct {
	query builder.Query
}

func (r userFindMany) getQuery() builder.Query {
	return r.query
}

func (r userFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userFindMany) with()         {}
func (r userFindMany) userModel()    {}
func (r userFindMany) userRelation() {}

func (r userActions) FindMany(
	params ...UserWhereParam,
) userFindMany {
	var v userFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "User"
	v.query.Outputs = userOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userFindMany) With(params ...UserRelationWith) userFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userFindMany) OrderBy(params ...UserOrderByParam) userFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userFindMany) Skip(count int) userFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userFindMany) Take(count int) userFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userFindMany) Cursor(cursor UserCursorParam) userFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userFindMany) Update(params ...UserSetParam) userUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userUpdateMany struct {
	query builder.Query
}

func (r userUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userUpdateMany) userModel() {}

func (r userUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userUpdateMany) Tx() userManyTxResult {
	v := NewuserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userFindMany) Delete() userDeleteMany {
	var v userDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userDeleteMany struct {
	query builder.Query
}

func (r userDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userDeleteMany) userModel() {}

func (r userDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userDeleteMany) Tx() userManyTxResult {
	v := NewuserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template transaction.gotpl ---

func NewuserUniqueTxResult() userUniqueTxResult {
	return userUniqueTxResult{
		result: &transaction.Result{},
	}
}

type userUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p userUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p userUniqueTxResult) IsTx() {}

func (r userUniqueTxResult) Result() (v *UserModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewuserManyTxResult() userManyTxResult {
	return userManyTxResult{
		result: &transaction.Result{},
	}
}

type userManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p userManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p userManyTxResult) IsTx() {}

func (r userManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

// --- template upsert.gotpl ---

type userUpsertOne struct {
	query builder.Query
}

func (r userUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r userUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r userUpsertOne) with()         {}
func (r userUpsertOne) userModel()    {}
func (r userUpsertOne) userRelation() {}

func (r userActions) UpsertOne(
	params UserEqualsUniqueWhereParam,
) userUpsertOne {
	var v userUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "User"
	v.query.Outputs = userOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r userUpsertOne) Create(

	_firstName UserWithPrismaFirstNameSetParam,
	_lastName UserWithPrismaLastNameSetParam,
	_email UserWithPrismaEmailSetParam,

	optional ...UserSetParam,
) userUpsertOne {
	var v userUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _firstName.field())
	fields = append(fields, _lastName.field())
	fields = append(fields, _email.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r userUpsertOne) Update(
	params ...UserSetParam,
) userUpsertOne {
	var v userUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r userUpsertOne) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userUpsertOne) Tx() userUniqueTxResult {
	v := NewuserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template client.gotpl ---
const schema = `datasource db {
    // could be postgresql or mysql
    provider = "postgresql"
    url      = "postgresql://postgres:dev@localhost:5432/app?schema=public"
}

generator db {
    provider = "go run github.com/prisma/prisma-client-go"
    // set the output folder and package name
    output           = "./"
    package          = "teste"
}

model User {
    id        String   @default(uuid()) @id
    created_at DateTime @default(now())
    updated_at DateTime @updatedAt
    first_name     String
    last_name String
    email String @unique
    age      String?

    @@map("users")
}`
const schemaConnectionURL = "postgresql://postgres:dev@localhost:5432/app?schema=public"
const schemaEnvVarName = ""

// hasBinaryTargets is true when binaryTargets are provided on generation time
var hasBinaryTargets = false

// NewClient creates a new Prisma Client Go client.
// The client is not connected to the Prisma engine yet.
//
// Example:
//
//	client := db.NewClient()
//	if err := client.Prisma.Connect(); err != nil {
//	  handle(err)
//	}
//
//	defer func() {
//	  if err := client.Prisma.Disconnect(); err != nil {
//	    panic(fmt.Errorf("could not disconnect: %w", err))
//	  }
//	}()
func NewClient() *PrismaClient {
	c := newClient()

	c.Engine = engine.NewQueryEngine(schema, hasBinaryTargets)

	c.Prisma.Lifecycle = &lifecycle.Lifecycle{Engine: c.Engine}

	return c
}

func newMockClient(expectations *[]mock.Expectation) *PrismaClient {
	c := newClient()
	c.Engine = mock.New(expectations)
	c.Prisma.Lifecycle = &lifecycle.Lifecycle{Engine: c.Engine}

	return c
}

func newClient() *PrismaClient {
	c := &PrismaClient{}
	c.User = userActions{client: c}

	c.Prisma = &PrismaActions{
		Raw: &raw.Raw{Engine: c},
		TX:  &transaction.TX{Engine: c},
	}
	return c
}

type PrismaActions struct {
	*lifecycle.Lifecycle
	*raw.Raw
	*transaction.TX
}

// PrismaClient is the instance of the Prisma Client Go client.
type PrismaClient struct {
	// engine is an abstractions of what happens under the hood
	// the query engine can spawn and manage the binary and send requests to it,
	// while a mock engine would collect mocks to verify them later
	engine.Engine

	// prisma provides prisma-related methods as opposed to model methods, such as Connect, Disconnect or raw queries
	Prisma *PrismaActions

	// User provides access to CRUD methods.
	User userActions
}

// --- template enums.gotpl ---

type UserScalarFieldEnum string

const (
	UserScalarFieldEnumID        UserScalarFieldEnum = "id"
	UserScalarFieldEnumCreatedAt UserScalarFieldEnum = "created_at"
	UserScalarFieldEnumUpdatedAt UserScalarFieldEnum = "updated_at"
	UserScalarFieldEnumFirstName UserScalarFieldEnum = "first_name"
	UserScalarFieldEnumLastName  UserScalarFieldEnum = "last_name"
	UserScalarFieldEnumEmail     UserScalarFieldEnum = "email"
	UserScalarFieldEnumAge       UserScalarFieldEnum = "age"
)

type SortOrder string

const (
	SortOrderAsc  SortOrder = "asc"
	SortOrderDesc SortOrder = "desc"
)

type QueryMode string

const (
	QueryModeDefault     QueryMode = "default"
	QueryModeInsensitive QueryMode = "insensitive"
)

// --- template errors.gotpl ---
var ErrNotFound = types.ErrNotFound

// --- template mock.gotpl ---
func NewMock() (*PrismaClient, *Mock, func(t *testing.T)) {
	expectations := new([]mock.Expectation)
	pc := newMockClient(expectations)
	m := &Mock{
		Mock: &mock.Mock{
			Expectations: expectations,
		},
	}

	m.User = userMock{
		mock: m,
	}

	return pc, m, m.Ensure
}

type Mock struct {
	*mock.Mock

	User userMock
}

type userMock struct {
	mock *Mock
}

type UserMockExpectParam interface {
	ExtractQuery() builder.Query
	userModel()
}

func (m *userMock) Expect(query UserMockExpectParam) *userMockExec {
	return &userMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type userMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *userMockExec) Returns(v UserModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *userMockExec) ReturnsMany(v []UserModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *userMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

// --- template models.gotpl ---

// UserModel represents the `json:"User"` model and is a wrapper for accessing fields and methods
type UserModel struct {
	InnerUser
	RelationsUser
}

// InnerUser holds the actual data
type InnerUser struct {
	ID        string   `json:"id"`
	CreatedAt DateTime `json:"created_at"`
	UpdatedAt DateTime `json:"updated_at"`
	FirstName string   `json:"first_name"`
	LastName  string   `json:"last_name"`
	Email     string   `json:"email"`
	Age       *string  `json:"age"`
}

// RelationsUser holds the relation data separately
type RelationsUser struct {
}

func (r UserModel) Age() (value string, ok bool) {
	if r.InnerUser.Age == nil {
		return value, false
	}
	return *r.InnerUser.Age, true
}

// --- template query.gotpl ---

// User acts as a namespaces to access query methods for the User model
var User = userQuery{}

// userQuery exposes query functions for the user model
type userQuery struct {

	// ID
	//
	// @required
	ID userQueryIDString

	// CreatedAt
	//
	// @required
	CreatedAt userQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt userQueryUpdatedAtDateTime

	// FirstName
	//
	// @required
	FirstName userQueryFirstNameString

	// LastName
	//
	// @required
	LastName userQueryLastNameString

	// Email
	//
	// @required
	// @unique
	Email userQueryEmailString

	// Age
	//
	// @optional
	Age userQueryAgeString
}

func (userQuery) Not(params ...UserWhereParam) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (userQuery) Or(params ...UserWhereParam) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (userQuery) And(params ...UserWhereParam) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type userQueryIDString struct{}

// Set the required value of ID
func (r userQueryIDString) Set(value string) userSetParam {

	return userSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r userQueryIDString) SetIfPresent(value *string) userSetParam {
	if value == nil {
		return userSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryIDString) Equals(value string) userWithPrismaIDEqualsUniqueParam {

	return userWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) EqualsIfPresent(value *string) userWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return userWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r userQueryIDString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r userQueryIDString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r userQueryIDString) In(value []string) userParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r userQueryIDString) InIfPresent(value []string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.In(value)
}

func (r userQueryIDString) NotIn(value []string) userParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r userQueryIDString) NotInIfPresent(value []string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.NotIn(value)
}

func (r userQueryIDString) Lt(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) LtIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Lt(*value)
}

func (r userQueryIDString) Lte(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) LteIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Lte(*value)
}

func (r userQueryIDString) Gt(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) GtIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Gt(*value)
}

func (r userQueryIDString) Gte(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) GteIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Gte(*value)
}

func (r userQueryIDString) Contains(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) ContainsIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Contains(*value)
}

func (r userQueryIDString) StartsWith(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) StartsWithIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r userQueryIDString) EndsWith(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) EndsWithIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r userQueryIDString) Mode(value QueryMode) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) ModeIfPresent(value *QueryMode) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Mode(*value)
}

func (r userQueryIDString) Not(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) NotIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryIDString) HasPrefix(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryIDString) HasPrefixIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryIDString) HasSuffix(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryIDString) HasSuffixIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.HasSuffix(*value)
}

// base struct
type userQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r userQueryCreatedAtDateTime) Set(value DateTime) userSetParam {

	return userSetParam{
		data: builder.Field{
			Name:  "created_at",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r userQueryCreatedAtDateTime) SetIfPresent(value *DateTime) userSetParam {
	if value == nil {
		return userSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryCreatedAtDateTime) Equals(value DateTime) userWithPrismaCreatedAtEqualsParam {

	return userWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) userWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return userWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryCreatedAtDateTime) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "created_at",
			Value: direction,
		},
	}
}

func (r userQueryCreatedAtDateTime) Cursor(cursor DateTime) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "created_at",
			Value: cursor,
		},
	}
}

func (r userQueryCreatedAtDateTime) In(value []DateTime) userDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) InIfPresent(value []DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryCreatedAtDateTime) NotIn(value []DateTime) userDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryCreatedAtDateTime) Lt(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) LtIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryCreatedAtDateTime) Lte(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) LteIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryCreatedAtDateTime) Gt(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) GtIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryCreatedAtDateTime) Gte(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) GteIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryCreatedAtDateTime) Not(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) NotIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r userQueryCreatedAtDateTime) Before(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r userQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r userQueryCreatedAtDateTime) After(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r userQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r userQueryCreatedAtDateTime) BeforeEquals(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r userQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r userQueryCreatedAtDateTime) AfterEquals(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "created_at",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r userQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type userQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r userQueryUpdatedAtDateTime) Set(value DateTime) userSetParam {

	return userSetParam{
		data: builder.Field{
			Name:  "updated_at",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r userQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) userSetParam {
	if value == nil {
		return userSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryUpdatedAtDateTime) Equals(value DateTime) userWithPrismaUpdatedAtEqualsParam {

	return userWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) userWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return userWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryUpdatedAtDateTime) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "updated_at",
			Value: direction,
		},
	}
}

func (r userQueryUpdatedAtDateTime) Cursor(cursor DateTime) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "updated_at",
			Value: cursor,
		},
	}
}

func (r userQueryUpdatedAtDateTime) In(value []DateTime) userDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) InIfPresent(value []DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryUpdatedAtDateTime) NotIn(value []DateTime) userDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryUpdatedAtDateTime) Lt(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryUpdatedAtDateTime) Lte(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryUpdatedAtDateTime) Gt(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryUpdatedAtDateTime) Gte(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryUpdatedAtDateTime) Not(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r userQueryUpdatedAtDateTime) Before(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r userQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r userQueryUpdatedAtDateTime) After(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r userQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r userQueryUpdatedAtDateTime) BeforeEquals(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r userQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r userQueryUpdatedAtDateTime) AfterEquals(value DateTime) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "updated_at",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r userQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type userQueryFirstNameString struct{}

// Set the required value of FirstName
func (r userQueryFirstNameString) Set(value string) userWithPrismaFirstNameSetParam {

	return userWithPrismaFirstNameSetParam{
		data: builder.Field{
			Name:  "first_name",
			Value: value,
		},
	}

}

// Set the optional value of FirstName dynamically
func (r userQueryFirstNameString) SetIfPresent(value *string) userWithPrismaFirstNameSetParam {
	if value == nil {
		return userWithPrismaFirstNameSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryFirstNameString) Equals(value string) userWithPrismaFirstNameEqualsParam {

	return userWithPrismaFirstNameEqualsParam{
		data: builder.Field{
			Name: "first_name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) EqualsIfPresent(value *string) userWithPrismaFirstNameEqualsParam {
	if value == nil {
		return userWithPrismaFirstNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryFirstNameString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "first_name",
			Value: direction,
		},
	}
}

func (r userQueryFirstNameString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "first_name",
			Value: cursor,
		},
	}
}

func (r userQueryFirstNameString) In(value []string) userDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "first_name",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) InIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryFirstNameString) NotIn(value []string) userDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "first_name",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) NotInIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryFirstNameString) Lt(value string) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "first_name",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) LtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryFirstNameString) Lte(value string) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "first_name",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) LteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryFirstNameString) Gt(value string) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "first_name",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) GtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryFirstNameString) Gte(value string) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "first_name",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) GteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryFirstNameString) Contains(value string) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "first_name",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) ContainsIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Contains(*value)
}

func (r userQueryFirstNameString) StartsWith(value string) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "first_name",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) StartsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r userQueryFirstNameString) EndsWith(value string) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "first_name",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) EndsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r userQueryFirstNameString) Mode(value QueryMode) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "first_name",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) ModeIfPresent(value *QueryMode) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Mode(*value)
}

func (r userQueryFirstNameString) Not(value string) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "first_name",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) NotIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryFirstNameString) HasPrefix(value string) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "first_name",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryFirstNameString) HasPrefixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryFirstNameString) HasSuffix(value string) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "first_name",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryFirstNameString) HasSuffixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type userQueryLastNameString struct{}

// Set the required value of LastName
func (r userQueryLastNameString) Set(value string) userWithPrismaLastNameSetParam {

	return userWithPrismaLastNameSetParam{
		data: builder.Field{
			Name:  "last_name",
			Value: value,
		},
	}

}

// Set the optional value of LastName dynamically
func (r userQueryLastNameString) SetIfPresent(value *string) userWithPrismaLastNameSetParam {
	if value == nil {
		return userWithPrismaLastNameSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryLastNameString) Equals(value string) userWithPrismaLastNameEqualsParam {

	return userWithPrismaLastNameEqualsParam{
		data: builder.Field{
			Name: "last_name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLastNameString) EqualsIfPresent(value *string) userWithPrismaLastNameEqualsParam {
	if value == nil {
		return userWithPrismaLastNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryLastNameString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "last_name",
			Value: direction,
		},
	}
}

func (r userQueryLastNameString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "last_name",
			Value: cursor,
		},
	}
}

func (r userQueryLastNameString) In(value []string) userDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "last_name",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r userQueryLastNameString) InIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryLastNameString) NotIn(value []string) userDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "last_name",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r userQueryLastNameString) NotInIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryLastNameString) Lt(value string) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "last_name",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryLastNameString) LtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryLastNameString) Lte(value string) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "last_name",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryLastNameString) LteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryLastNameString) Gt(value string) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "last_name",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryLastNameString) GtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryLastNameString) Gte(value string) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "last_name",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryLastNameString) GteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryLastNameString) Contains(value string) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "last_name",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryLastNameString) ContainsIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Contains(*value)
}

func (r userQueryLastNameString) StartsWith(value string) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "last_name",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryLastNameString) StartsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r userQueryLastNameString) EndsWith(value string) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "last_name",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryLastNameString) EndsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r userQueryLastNameString) Mode(value QueryMode) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "last_name",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryLastNameString) ModeIfPresent(value *QueryMode) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Mode(*value)
}

func (r userQueryLastNameString) Not(value string) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "last_name",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryLastNameString) NotIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryLastNameString) HasPrefix(value string) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "last_name",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryLastNameString) HasPrefixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryLastNameString) HasSuffix(value string) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "last_name",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryLastNameString) HasSuffixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type userQueryEmailString struct{}

// Set the required value of Email
func (r userQueryEmailString) Set(value string) userWithPrismaEmailSetParam {

	return userWithPrismaEmailSetParam{
		data: builder.Field{
			Name:  "email",
			Value: value,
		},
	}

}

// Set the optional value of Email dynamically
func (r userQueryEmailString) SetIfPresent(value *string) userWithPrismaEmailSetParam {
	if value == nil {
		return userWithPrismaEmailSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryEmailString) Equals(value string) userWithPrismaEmailEqualsUniqueParam {

	return userWithPrismaEmailEqualsUniqueParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) EqualsIfPresent(value *string) userWithPrismaEmailEqualsUniqueParam {
	if value == nil {
		return userWithPrismaEmailEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r userQueryEmailString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "email",
			Value: direction,
		},
	}
}

func (r userQueryEmailString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "email",
			Value: cursor,
		},
	}
}

func (r userQueryEmailString) In(value []string) userParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r userQueryEmailString) InIfPresent(value []string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.In(value)
}

func (r userQueryEmailString) NotIn(value []string) userParamUnique {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r userQueryEmailString) NotInIfPresent(value []string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.NotIn(value)
}

func (r userQueryEmailString) Lt(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) LtIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Lt(*value)
}

func (r userQueryEmailString) Lte(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) LteIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Lte(*value)
}

func (r userQueryEmailString) Gt(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) GtIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Gt(*value)
}

func (r userQueryEmailString) Gte(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) GteIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Gte(*value)
}

func (r userQueryEmailString) Contains(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) ContainsIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Contains(*value)
}

func (r userQueryEmailString) StartsWith(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) StartsWithIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r userQueryEmailString) EndsWith(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) EndsWithIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r userQueryEmailString) Mode(value QueryMode) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) ModeIfPresent(value *QueryMode) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Mode(*value)
}

func (r userQueryEmailString) Not(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) NotIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryEmailString) HasPrefix(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryEmailString) HasPrefixIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryEmailString) HasSuffix(value string) userParamUnique {

	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryEmailString) HasSuffixIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.HasSuffix(*value)
}

// base struct
type userQueryAgeString struct{}

// Set the optional value of Age
func (r userQueryAgeString) Set(value string) userSetParam {

	return userSetParam{
		data: builder.Field{
			Name:  "age",
			Value: value,
		},
	}

}

// Set the optional value of Age dynamically
func (r userQueryAgeString) SetIfPresent(value *string) userSetParam {
	if value == nil {
		return userSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of Age dynamically
func (r userQueryAgeString) SetOptional(value *string) userSetParam {
	if value == nil {

		var v *string
		return userSetParam{
			data: builder.Field{
				Name:  "age",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r userQueryAgeString) Equals(value string) userWithPrismaAgeEqualsParam {

	return userWithPrismaAgeEqualsParam{
		data: builder.Field{
			Name: "age",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAgeString) EqualsIfPresent(value *string) userWithPrismaAgeEqualsParam {
	if value == nil {
		return userWithPrismaAgeEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryAgeString) EqualsOptional(value *string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "age",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAgeString) IsNull() userDefaultParam {
	var str *string = nil
	return userDefaultParam{
		data: builder.Field{
			Name: "age",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r userQueryAgeString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "age",
			Value: direction,
		},
	}
}

func (r userQueryAgeString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "age",
			Value: cursor,
		},
	}
}

func (r userQueryAgeString) In(value []string) userDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "age",
			Fields: []builder.Field{
				{
					Name: "in",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r userQueryAgeString) InIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryAgeString) NotIn(value []string) userDefaultParam {

	var fields []builder.Field
	for _, v := range value {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "age",
			Fields: []builder.Field{
				{
					Name: "notIn",

					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r userQueryAgeString) NotInIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryAgeString) Lt(value string) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "age",
			Fields: []builder.Field{
				{
					Name: "lt",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryAgeString) LtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryAgeString) Lte(value string) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "age",
			Fields: []builder.Field{
				{
					Name: "lte",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryAgeString) LteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryAgeString) Gt(value string) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "age",
			Fields: []builder.Field{
				{
					Name: "gt",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryAgeString) GtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryAgeString) Gte(value string) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "age",
			Fields: []builder.Field{
				{
					Name: "gte",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryAgeString) GteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryAgeString) Contains(value string) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "age",
			Fields: []builder.Field{
				{
					Name: "contains",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryAgeString) ContainsIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Contains(*value)
}

func (r userQueryAgeString) StartsWith(value string) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "age",
			Fields: []builder.Field{
				{
					Name: "startsWith",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryAgeString) StartsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r userQueryAgeString) EndsWith(value string) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "age",
			Fields: []builder.Field{
				{
					Name: "endsWith",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryAgeString) EndsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r userQueryAgeString) Mode(value QueryMode) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "age",
			Fields: []builder.Field{
				{
					Name: "mode",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryAgeString) ModeIfPresent(value *QueryMode) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Mode(*value)
}

func (r userQueryAgeString) Not(value string) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "age",
			Fields: []builder.Field{
				{
					Name: "not",

					Value: value,
				},
			},
		},
	}
}

func (r userQueryAgeString) NotIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryAgeString) HasPrefix(value string) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "age",
			Fields: []builder.Field{
				{
					Name: "starts_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryAgeString) HasPrefixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryAgeString) HasSuffix(value string) userDefaultParam {

	return userDefaultParam{
		data: builder.Field{
			Name: "age",
			Fields: []builder.Field{
				{
					Name: "ends_with",

					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryAgeString) HasSuffixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasSuffix(*value)
}
